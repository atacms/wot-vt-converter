# created by atacms, 13/12/2018
# output vt format as observed in WoT 1.3.0.1
# tested with obj created by 3dsmax2012, model facing front, with 'flip YZ-axis' option
# sometimes the model needs to be rotated 180 facing scene rear. it probably depends on how tank chssis is built.

import pdb
#import subprocess
import sys
import argparse
import os
from ctypes import c_long
from struct import unpack
from struct import pack
from glob import glob

class Vertice:
	def __init__(self):
		self.x = None
		self.y = None
		self.z = None
		
parser = argparse.ArgumentParser(description='convert first group from obj to vt(bsp).')
parser.add_argument('input', help='obj file path, tested with obj generated by 3dsmax2012')
parser.add_argument('-o','--output', dest='vt', help='result vt filename')



def main(filename_obj):
	filename = os.path.splitext(filename_obj)[0]
	filename_vt = '%s.vt' %filename
	if args.vt != None:
			filename_vt = args.vt
	if not os.path.exists(filename_obj):
			print("Failed to find %s" % filename_obj)
			sys.exit(1)

	with open(filename_obj, 'rb') as mainFP:
		isProcessed = False
		vertices = []
		indicies = []
		minx=0
		miny=0
		minz=0
		maxx=0
		maxy=0
		maxz=0
		while True:
			line = mainFP.readline().decode('utf-8')
			if line=='':
				break
			if line.startswith('#'):
				continue
			elif line.startswith('v '):
				vert = Vertice()
				_ = line.split()
				vert.x = float(_[1])
				vert.y = float(_[2])
				vert.z = - float(_[3])
				minx = vert.x if vert.x < minx else minx
				minY = vert.y if vert.y < miny else miny
				minz = vert.z if vert.z < minz else minz
				maxx = vert.x if vert.x > maxx else maxx
				maxy = vert.y if vert.y > maxy else maxy
				maxz = vert.z if vert.z > maxz else maxz
#				print ('(%f, %f, %f)'%(vert.x, vert.y, vert.z))
				vertices.append(vert)
				continue
			elif line.startswith('g '):
				if not isProcessed:
					isProcessed = True
					while True:
						line = mainFP.readline().decode('utf-8')
						if line=='':
							break
						if line.startswith('g ') or line.startswith('vt ') or line.startswith('vn ') or line.startswith('v '):
							break
						elif line.startswith('f '):
							_ = line.split()[1::]
							for i in [0,2,1]:
								if '/' in _[i]:
									indicies.append(int(_[i].split('/')[0])-1)
								else:
									indicies.append(int(_[i])-1)
									
		print ('bsp loaded into memory')
#		print vertices
#		print indicies
		print ('reconstructed boundingbox:')
		print (minx, miny, minz)
		print (maxx, maxy, maxz)
			
		with open(filename_vt, 'wb') as vtFP:
				vtFP.write(b'\x0b\xb0\x0b\xb0\x02\x00\x00\x00')
				vtFP.write(pack('f',minx))
				vtFP.write(pack('f',miny))
				vtFP.write(pack('f',minz))
				vtFP.write(pack('f',maxx))
				vtFP.write(pack('f',maxy))
				vtFP.write(pack('f',maxz))
				v_count = len(vertices)
				print ('v_count = %d' %v_count)
				vtFP.write(pack('I',v_count))
				for v in vertices:
					vtFP.write(pack('f',v.x))
					vtFP.write(pack('f',v.y))
					vtFP.write(pack('f',v.z))
				vtFP.write(pack('I',len(indicies)))
				if len(indicies) <= 65535:
					vtFP.write(b'\x01')
					for ele in indicies:
						vtFP.write(pack('H',ele))
				else:
					print ('bsp is very large. ')
					vtFP.write(b'\x02')
					for ele in indicies:
						vtFP.write(pack('I',ele))
				vtFP.write(b'\x01\x00\x00\x00\x00\x00\x00\x00')
				vtFP.write(pack('I',v_count))
				vtFP.close()
				print ('Done')
				
				

		
args = parser.parse_args()
for fname in glob(args.input):
	print('\nprocessing %s' % fname)
	main(fname)

